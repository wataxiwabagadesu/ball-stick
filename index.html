<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<title>Ball-Stick 分子生成器（2D → 3D）</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/kekule/dist/themes/default/kekule.css" />
<style>
  html, body { margin:0; height:100%; font-family: system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif; }
  header { padding:10px 14px; border-bottom:1px solid #ddd; display:flex; flex-wrap:wrap; gap:8px; align-items:center; background:#fff; }
  input, button { padding:6px 10px; border-radius:8px; border:1px solid #ccc; }
  button { cursor:pointer; background:#f6f7ff; border-color:#cfd8ff; }
  button:active { transform: translateY(1px); }
  #status { font-size:12px; color:#333; }
  #main { height: calc(100% - 64px); display:grid; grid-template-columns: 1.1fr 0.9fr; gap:10px; padding:10px; background:#f7f7f9; box-sizing:border-box; }
  .panel { background:#fff; border:1px solid rgba(0,0,0,.08); border-radius:12px; overflow:hidden; display:flex; flex-direction:column; min-height:0; }
  .panel h3 { margin:0; padding:8px 12px; background:#f3f3f3; font-size:14px; border-bottom:1px solid #ddd; }
  .panel .body { flex:1; min-height:0; }
  #composer, #viewer3d { width:100%; height:100%; }
</style>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/kekule/dist/kekule.js?modules=io,chemWidget,calculation,openbabel&locals=en,zh&language=zh"></script>

<script>
  // ★ 同源 OpenBabel / worker 目录（GitHub Pages 必须）
  const extraPath = new URL('./assets/kekule/extra/', document.baseURI).toString();
  Kekule.environment.setEnvVar('openbabel.path', extraPath);
</script>
</head>

<body>
<header>
  <b>Ball-Stick 分子生成器</b>
  <input id="inpSmiles" placeholder="输入 SMILES（如 CCO）" style="min-width:240px">
  <button id="btnLoadSmiles">SMILES → 2D</button>
  <button id="btnGen3D">生成 3D</button>
  <button id="btnClear">清空</button>
  <span id="status">状态：初始化中…</span>
</header>

<div id="main">
  <div class="panel">
    <h3>二维结构编辑器</h3>
    <div class="body" id="composer"></div>
  </div>
  <div class="panel">
    <h3>三维球棍模型</h3>
    <div class="body" id="viewer3d"></div>
  </div>
</div>

<script>
const $ = id => document.getElementById(id);
const statusEl = $("status");
function setStatus(msg) { statusEl.textContent = msg; console.log("[STATUS]", msg); }

// 安全调用：方法存在才调用（兼容不同 Kekule 版本）
function safeCall(obj, methodName, ...args) {
  if (obj && typeof obj[methodName] === "function") return obj[methodName](...args);
  return undefined;
}

async function checkUrl(url) {
  try {
    const r = await fetch(url, { method: "GET" });
    return { ok: r.ok, status: r.status, url };
  } catch {
    return { ok: false, status: "FETCH_ERR", url };
  }
}

async function selfCheckAssets() {
  const jsUrl = new URL('./assets/kekule/extra/openbabel.js', document.baseURI).toString();
  const wasmUrl = new URL('./assets/kekule/extra/openbabel.wasm', document.baseURI).toString();
  const dataUrl = new URL('./assets/kekule/extra/openbabel.data', document.baseURI).toString();
  const workerUrl = new URL('./assets/kekule/extra/kekule.worker.obStructureGenerator.js', document.baseURI).toString();

  const [a,b,c,d] = await Promise.all([checkUrl(jsUrl), checkUrl(wasmUrl), checkUrl(dataUrl), checkUrl(workerUrl)]);
  console.log("Asset checks:", { a,b,c,d });

  if (!a.ok || !b.ok || !c.ok || !d.ok) {
    setStatus("状态：资源不可用（openbabel/worker 可能 404）— 见 Console");
    alert(
      "OpenBabel/Worker 资源无法访问（可能 404）。\n\n" +
      `openbabel.js: ${a.status}\n` +
      `openbabel.wasm: ${b.status}\n` +
      `openbabel.data: ${c.status}\n` +
      `kekule.worker...js: ${d.status}\n\n` +
      "请确认这些文件在 assets/kekule/extra/，且 GitHub Pages 发布目录是仓库 root。"
    );
    return false;
  }
  return true;
}

let composerWidget = null;
let viewerWidget = null;

function initWidgets() {
  // 2D 编辑器：不同版本 API 不同，尽量少碰易变方法
  composerWidget = new Kekule.Editor.Composer($("composer"));

  // 尝试开启工具栏（如果该版本支持）
  safeCall(composerWidget, "setEnableToolbar", true);
  // 有些版本用 setToolbarDisplayed / setToolbarVisible
  safeCall(composerWidget, "setToolbarDisplayed", true);
  safeCall(composerWidget, "setToolbarVisible", true);

  // 3D Viewer
  viewerWidget = new Kekule.ChemWidget.Viewer3D($("viewer3d"));
  safeCall(viewerWidget, "setEnableToolbar", true);
  safeCall(viewerWidget, "setToolbarDisplayed", true);
  safeCall(viewerWidget, "setToolbarVisible", true);

  // 设置球棍显示（如果该版本支持这个枚举/方法）
  if (Kekule.Render && Kekule.Render.Molecule3DDisplayType && Kekule.Render.Molecule3DDisplayType.BALL_STICK) {
    safeCall(viewerWidget, "setMoleculeDisplayType", Kekule.Render.Molecule3DDisplayType.BALL_STICK);
  }
}

function ensureOpenBabel() {
  return new Promise((resolve, reject) => {
    if (Kekule.OpenBabel && Kekule.OpenBabel.isAvailable && Kekule.OpenBabel.isAvailable()) {
      resolve();
      return;
    }
    setStatus("状态：正在加载 OpenBabel…");
    let done = false;
    const timer = setTimeout(() => {
      if (done) return;
      done = true;
      reject(new Error("OpenBabel 加载超时（检查资源/控制台报错）"));
    }, 12000);

    Kekule.OpenBabel.enable(err => {
      if (done) return;
      clearTimeout(timer);
      done = true;
      if (err) reject(err);
      else resolve();
    });
  });
}

// 从 ChemObj（可能是容器）里提取第一个真正的分子
function pickMol(obj) {
  if (!obj) return null;
  if (obj instanceof Kekule.StructureFragment) return obj;
  if (obj instanceof Kekule.Molecule) return obj;

  if (typeof obj.getChildCount === "function" && typeof obj.getChildAt === "function") {
    for (let i = 0; i < obj.getChildCount(); i++) {
      const found = pickMol(obj.getChildAt(i));
      if (found) return found;
    }
  }
  if (typeof obj.getChildren === "function") {
    const kids = obj.getChildren() || [];
    for (const c of kids) {
      const found = pickMol(c);
      if (found) return found;
    }
  }
  return null;
}

async function loadSmiles() {
  const smiles = $("inpSmiles").value.trim();
  if (!smiles) return;

  await ensureOpenBabel();
  setStatus("状态：导入 SMILES 并生成 2D…");

  const mol = Kekule.IO.loadFormatData(smiles, "smi");
  const gen2d = new Kekule.Calculator.ObStructure2DGenerator();
  gen2d.setSourceMol(mol);

  await new Promise((res, rej) => gen2d.execute(e => e ? rej(e) : res()));

  const out = gen2d.getGeneratedMol ? gen2d.getGeneratedMol() : null;
  safeCall(composerWidget, "setChemObj", out || mol);
  setStatus("状态：2D 已生成（可编辑）");
}

async function gen3D() {
  await ensureOpenBabel();

  const raw = safeCall(composerWidget, "getChemObj");
  const mol = pickMol(raw);
  if (!mol) { alert("请先画一个分子或导入 SMILES"); return; }

  setStatus("状态：生成 3D 坐标…");
  const gen3d = new Kekule.Calculator.ObStructure3DGenerator();
  gen3d.setSourceMol(mol);

  await new Promise((res, rej) => gen3d.execute(e => e ? rej(e) : res()));

  const mol3D = gen3d.getGeneratedMol ? gen3d.getGeneratedMol() : null;
  safeCall(viewerWidget, "setChemObj", mol3D || mol);
  safeCall(viewerWidget, "zoomToFit");
  setStatus("状态：3D 球棍模型已生成");
}

function clearAll() {
  safeCall(composerWidget, "setChemObj", null);
  safeCall(viewerWidget, "setChemObj", null);
  $("inpSmiles").value = "";
  setStatus("状态：已清空");
}

$("btnLoadSmiles").onclick = () => loadSmiles().catch(e => { console.error(e); alert(e.message || e); });
$("btnGen3D").onclick = () => gen3D().catch(e => { console.error(e); alert(e.message || e); });
$("btnClear").onclick = clearAll;

Kekule.X.domReady(async () => {
  try {
    setStatus("状态：domReady 触发，检查资源…");
    const ok = await selfCheckAssets();
    if (!ok) return;

    initWidgets();
    setStatus("状态：就绪（请输入 SMILES，例如 CCO）");
  } catch (e) {
    console.error(e);
    setStatus("状态：初始化失败（见 Console）");
    alert("初始化失败：\n" + (e.message || e));
  }
});
</script>
</body>
</html>
